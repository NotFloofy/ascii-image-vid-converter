<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>custom ascii converter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#06070a;
      --panel:#0b1620;
      --muted:#95a3af;
      --primary1:#0b6fb0;
      --primary2:#0078bf;
      --accent:#00d4ff;
      --glass: rgba(255,255,255,0.02);
      --radius:12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#020205);color:#e6eef6;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased}
    .site{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:14px;
      padding:20px;
      align-items:center;
      justify-content:flex-start;
    }
    .header{
      width:100%;
      max-width:1200px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    .panel{
      width:100%;
      max-width:1200px;
      background:linear-gradient(180deg,var(--panel),#07101a);
      border-radius:var(--radius);
      box-shadow:0 14px 40px rgba(2,6,23,0.7);
      padding:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .topcontrols{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .left{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .inputfile{
      padding:8px 10px;
      background:#071a2a;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.03);
      color:#e6eef6;
      cursor:pointer;
      font-size:14px;
    }
    .num{
      width:120px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.03);
      background:#071a2a;
      color:#e6eef6;
    }
    .btn{
      padding:10px 14px;
      border-radius:10px;
      border:0;
      cursor:pointer;
      font-weight:700;
      color:#fff;
      background:linear-gradient(90deg,var(--primary1),var(--primary2));
      box-shadow: 0 8px 20px rgba(3,80,140,0.16);
    }
    .btn.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:700;
    }
    .meta{
      color:var(--muted);
      font-size:13px;
    }
    .previewwrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .previewbox{
      width:100%;
      height:58vh;
      min-height:260px;
      max-height:78vh;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      overflow:hidden;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .previewtop{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .asciicontainer{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      background:rgba(0,0,0,0.02);
      border-radius:8px;
      padding:6px;
      position:relative;
    }
    pre#display{
      margin:0;
      padding:0;
      font-family:var(--mono);
      color:#e6eef6;
      line-height:1;
      white-space:pre;
      transform-origin:0 0;
      overflow:auto;
    }
    #progresscontainer{
      width:100%;
      height:10px;
      background:rgba(255,255,255,0.03);
      border-radius:8px;
      overflow:hidden;
      display:none;
    }
    #progressbar{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,var(--accent),#66f2ff);
      transition:width .12s linear;
    }
    #progressmessage{color:var(--muted);font-size:13px}
    @media (max-width:900px){
      .previewbox{height:52vh}
      .num{width:100%}
      .left{flex-direction:column;align-items:flex-start}
    }
  </style>
</head>
<body>
  <div class="site">
    <div class="header">
      <div style="color:#cfe9ff;font-weight:800">custom ascii converter</div>
      <div class="meta" id="filemeta">no file selected</div>
    </div>
    <div class="panel">
      <div class="topcontrols">
        <div class="left">
          <label class="inputfile">
            select file
            <input id="mediainput" type="file" accept="image/*,video/*" style="display:none">
          </label>
          <input id="detailsize" class="num" type="number" min="50" step="50" value="200" title="columns">
          <button id="customprocess" class="btn">process</button>
          <button id="savecustom" class="btn">save ascii</button>
          <button id="togglecolour" class="btn secondary">colour mode off</button>
        </div>
        <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
          <div id="info" class="meta">preview at bottom, will fit to view</div>
          <div id="progressmessage" class="meta"></div>
        </div>
      </div>
      <div class="previewwrap">
        <div id="progresscontainer"><div id="progressbar"></div></div>
        <div class="previewbox" aria-live="polite">
          <div class="previewtop">
            <div class="meta">ascii preview (zoom-to-fit)</div>
            <div class="meta" id="previewmeta"></div>
          </div>
          <div class="asciicontainer" id="asciicontainer">
            <pre id="display" aria-hidden="false"></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let custommedia = null;
    let customctx = null;
    let customcanvas = document.createElement('canvas');
    let recordingCanvas = document.createElement('canvas');
    let recordingCtx = recordingCanvas.getContext('2d');
    let custommediatype = null;
    let usecolour = false;
    let asciiData = [];
    const charset = " '_.,-=+:;cba!?0123456789$W#@Ñ";
    const display = document.getElementById('display');
    const asciicontainer = document.getElementById('asciicontainer');
    const progresscontainer = document.getElementById('progresscontainer');
    const progressbar = document.getElementById('progressbar');
    const progressmessage = document.getElementById('progressmessage');
    const filemeta = document.getElementById('filemeta');
    const previewmeta = document.getElementById('previewmeta');

    recordingCanvas.style.display = 'none';
    document.body.appendChild(recordingCanvas);

    function setMeta(text){ filemeta.textContent = text || 'no file selected'; previewmeta.textContent = text || ''; }

    let isRecording = false;
    let domSkipCounter = 0;
    let domThrottle = 1;

    function renderAsciiOnce(opts = {updateDom:true, drawRecording:true}){
      if (!custommedia || !customctx) return;
      const detail = Math.max(50, parseInt(document.getElementById('detailsize').value) || 200);
      let aspect = 1;
      if (custommediatype === 'video' && custommedia.videoWidth && custommedia.videoHeight) aspect = custommedia.videoHeight / custommedia.videoWidth;
      if (custommediatype === 'image' && custommedia.naturalWidth && custommedia.naturalHeight) aspect = custommedia.naturalHeight / custommedia.naturalWidth;
      customcanvas.width = detail;
      customcanvas.height = Math.max(1, Math.floor(detail * aspect));
      customctx.drawImage(custommedia, 0, 0, customcanvas.width, customcanvas.height);

      const img = customctx.getImageData(0,0,customcanvas.width,customcanvas.height).data;
      asciiData.length = 0;
      let out = '';
      const cols = customcanvas.width;
      const rows = customcanvas.height;
      const charsetLen = charset.length;

      for (let y=0;y<rows;y++){
        let row = new Array(cols);
        if (opts.updateDom) out += '';
        for (let x=0;x<cols;x++){
          const i = (y*cols + x)*4;
          const r = img[i], g = img[i+1], b = img[i+2];
          const brightness = 0.299*r + 0.587*g + 0.114*b;
          const idx = Math.floor((brightness/255)*(charsetLen-1));
          const ch = charset.charAt(idx);
          const color = usecolour ? `rgb(${r},${g},${b})` : '#e6eef6';
          row[x] = {char:ch, color:color, r:r, g:g, b:b};
          if (opts.updateDom){
            if (usecolour) out += `<span style="color:${color}">${ch}</span>`;
            else out += ch;
          }
        }
        asciiData.push(row);
        if (opts.updateDom) out += '\n';
      }

      if (opts.updateDom){
        if (!isRecording || domSkipCounter % domThrottle === 0) display.innerHTML = out;
        domSkipCounter++;
      }

      const fontSize = 10;
      const fontW = fontSize * 0.6;
      const fontH = fontSize * 1.2;
      recordingCanvas.width = Math.max(120, Math.round(cols * fontW));
      recordingCanvas.height = Math.max(120, Math.round(rows * fontH));
      recordingCtx.fillStyle = '#06070a';
      recordingCtx.fillRect(0,0,recordingCanvas.width,recordingCanvas.height);
      recordingCtx.font = `${fontSize}px monospace`;
      recordingCtx.textBaseline = 'top';

      if (opts.drawRecording){
        for (let y=0;y<asciiData.length;y++){
          const row = asciiData[y];
          for (let x=0;x<row.length;x++){
            const obj = row[x];
            recordingCtx.fillStyle = obj.color;
            recordingCtx.fillText(obj.char, x * fontW, y * fontH);
          }
        }
      }

      fitPreviewToContainer();
    }

    function fitPreviewToContainer(){
      if (!asciiData || asciiData.length === 0) return;
      const cols = asciiData[0].length;
      const rows = asciiData.length;
      const containerW = asciicontainer.clientWidth - 6;
      const containerH = asciicontainer.clientHeight - 6;
      const fontSizeByWidth = containerW / (cols * 0.6);
      const fontSizeByHeight = containerH / (rows * 1.2);
      let fontSize = Math.floor(Math.min(fontSizeByWidth, fontSizeByHeight));
      if (fontSize < 4) fontSize = 4;
      if (fontSize > 18) fontSize = Math.min(fontSize, 18);
      display.style.fontSize = fontSize + 'px';
      display.style.lineHeight = '1';
      display.style.margin = '0 auto';
      if (!usecolour) display.style.color = '#e6eef6';
    }

    let liveId = null;
    function startLivePreview(){
      if (liveId) cancelAnimationFrame(liveId);
      function tick(){
        if (!custommedia) return;
        renderAsciiOnce({updateDom: !isRecording, drawRecording:true});
        if (custommediatype === 'video' && !custommedia.paused) liveId = requestAnimationFrame(tick);
      }
      liveId = requestAnimationFrame(tick);
    }

    document.getElementById('customprocess').addEventListener('click', () => {
      const f = document.getElementById('mediainput').files[0];
      if (!f) return;
      setMeta(`${f.name} • ${Math.round(f.size/1024)}KB`);
      if (f.type.startsWith('image')){
        custommediatype = 'image';
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          custommedia = img;
          customcanvas = document.createElement('canvas');
          customctx = customcanvas.getContext('2d');
          renderAsciiOnce({updateDom:true, drawRecording:true});
        };
        img.src = URL.createObjectURL(f);
      } else if (f.type.startsWith('video')){
        custommediatype = 'video';
        const vid = document.createElement('video');
        vid.crossOrigin = 'anonymous';
        vid.muted = true;
        vid.playsInline = true;
        vid.controls = false;
        vid.loop = false;
        vid.onloadeddata = () => {
          custommedia = vid;
          customcanvas = document.createElement('canvas');
          customctx = customcanvas.getContext('2d');
          vid.play().catch(()=>{ });
          startLivePreview();
        };
        vid.src = URL.createObjectURL(f);
      } else {
        setMeta('unsupported file');
      }
    });

    document.querySelector('.inputfile').addEventListener('click', () => {
      document.getElementById('mediainput').click();
    });
    document.getElementById('mediainput').addEventListener('change', () => {
      const f = document.getElementById('mediainput').files[0];
      if (f) setMeta(`${f.name} • ${Math.round(f.size/1024)}KB`);
    });

    document.getElementById('togglecolour').addEventListener('click', function(){
      usecolour = !usecolour;
      this.textContent = usecolour ? 'colour mode on' : 'colour mode off';
      if (custommedia) renderAsciiOnce({updateDom:true, drawRecording:true});
    });

    document.getElementById('savecustom').addEventListener('click', async () => {
      if (!custommedia) return;
      if (custommediatype === 'image'){
        if (!asciiData.length) renderAsciiOnce({updateDom:true, drawRecording:true});
        const rows = asciiData.length;
        const cols = asciiData[0].length;
        const fontSize = 10;
        const lineHeight = fontSize * 1.2;
        const canvasw = Math.max(120, Math.round(cols * fontSize * 0.6));
        const canvash = Math.max(120, Math.round(rows * lineHeight));
        const off = document.createElement('canvas');
        off.width = canvasw;
        off.height = canvash;
        const ctx = off.getContext('2d');
        ctx.fillStyle = '#06070a';
        ctx.fillRect(0,0,canvasw,canvash);
        ctx.font = `${fontSize}px monospace`;
        for (let y=0;y<rows;y++){
          for (let x=0;x<cols;x++){
            const obj = asciiData[y][x];
            ctx.fillStyle = obj.color;
            ctx.fillText(obj.char, x * fontSize * 0.6, (y+1) * lineHeight);
          }
        }
        off.toBlob(b => {
          const url = URL.createObjectURL(b);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'ascii_art.png';
          document.body.appendChild(a);
          a.click();
          setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 1500);
        });
        return;
      }

      progresscontainer.style.display = 'block';
      progressbar.style.width = '0%';
      progressmessage.textContent = 'initializing render...';

      renderAsciiOnce({updateDom:false, drawRecording:true});

      const captureFps = 60;
      const supportedMimeCandidates = [
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm'
      ];
      let mime = supportedMimeCandidates.find(m => {
        try { return MediaRecorder.isTypeSupported(m); } catch(e){ return false; }
      }) || 'video/webm';

      const stream = (recordingCanvas.captureStream) ? recordingCanvas.captureStream(captureFps) : recordingCanvas.captureStream();
      const chunks = [];
      let recorder;
      try {
        recorder = new MediaRecorder(stream, { mimeType: mime });
      } catch(e){
        recorder = new MediaRecorder(stream);
      }
      recorder.ondataavailable = ev => { if (ev.data && ev.data.size) chunks.push(ev.data); };
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: mime });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ascii_art.webm';
        document.body.appendChild(a);
        a.click();
        setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 1500);
      };

      try { custommedia.pause(); custommedia.currentTime = 0; } catch(e){}

      recorder.start();

      isRecording = true;
      domThrottle = 8;
      domSkipCounter = 0;

      await custommedia.play().catch(()=>{ });

      await new Promise(resolve => {
        const duration = custommedia.duration || 0;
        function handleFrame(){
          try {
            renderAsciiOnce({updateDom:false, drawRecording:true});
          } catch(e){ }
          const t = Math.min(custommedia.currentTime || 0, duration);
          const pct = duration ? Math.floor((t / duration) * 100) : 0;
          progressbar.style.width = pct + '%';
          progressmessage.textContent = `time: ${Math.floor(t)}s / ${Math.floor(duration)}s, ${pct}%`;
          if (duration && custommedia.currentTime < duration - 0.015 && !custommedia.ended) {
            if ('requestVideoFrameCallback' in custommedia) {
              try { custommedia.requestVideoFrameCallback(() => handleFrame()); } catch(err){ requestAnimationFrame(handleFrame); }
            } else {
              requestAnimationFrame(handleFrame);
            }
          } else {
            renderAsciiOnce({updateDom:false, drawRecording:true});
            progressbar.style.width = '100%';
            progressmessage.textContent = 'finalizing encode...';
            setTimeout(() => {
              try { recorder.stop(); } catch(e){}
              setTimeout(() => {
                progresscontainer.style.display = 'none';
                progressmessage.textContent = '';
                isRecording = false;
                domThrottle = 1;
                resolve();
              }, 700);
            }, 200);
          }
        }
        if ('requestVideoFrameCallback' in custommedia) {
          try { custommedia.requestVideoFrameCallback(() => handleFrame()); }
          catch(e){ requestAnimationFrame(handleFrame); }
        } else {
          requestAnimationFrame(handleFrame);
        }
      });

    });

    document.getElementById('detailsize').addEventListener('change', () => {
      if (custommedia) renderAsciiOnce({updateDom:true, drawRecording:true});
    });

    customctx = customcanvas.getContext('2d');
  </script>
</body>
</html>

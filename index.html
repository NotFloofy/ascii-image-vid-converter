<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>ascii conversion</title>
  <script>
    if (/mobi|android/i.test(navigator.userAgent)) {
      let meta = document.createElement("meta");
      meta.name = "viewport";
      meta.content = "width=device-width,initial-scale=1,minimum-scale=0.1,maximum-scale=5,user-scalable=yes";
      document.getElementsByTagName("head")[0].appendChild(meta);
    }
  </script>
  <style>
    body {
      margin: 0;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: monospace;
    }
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1em;
    }
    button,
    input[type="button"],
    input[type="submit"],
    input[type="reset"] {
      background: #003366;
      border: none;
      color: #e0e0e0;
      padding: 0.5em 1em;
      margin: 0.5em;
      font-size: 1em;
      border-radius: 4px;
      transition: background 0.3s;
      cursor: pointer;
    }
    button:hover,
    input[type="button"]:hover,
    input[type="submit"]:hover,
    input[type="reset"]:hover {
      background: #005599;
    }

    input[type="file"] {
      display: none;
    }
    label {
       background: #003366;
      border: none;
      color: #e0e0e0;
      padding: 0.5em 1em;
      margin: 0.5em;
      font-size: 1em;
      border-radius: 4px;
      transition: background 0.3s;
      cursor: pointer;
      display: inline-block;
    }
     label:hover {
      background: #005599;
    }

    input[type="number"] {
       background: #003366;
       border: none;
       color: #e0e0e0;
       padding: 0.5em 1em;
       margin: 0.5em;
       font-size: 1em;
       border-radius: 4px;
       transition: background 0.3s;
    }


    #display {
      margin: 0 auto;
      padding: 1em;
      width: 90%;
      text-align: center;
    }

     #display canvas {
        display: block;
        margin: 0 auto;
        max-width: 100%; /* Ensure canvas fits within its container */
        height: auto; /* Maintain aspect ratio */
     }

    #progresscontainer {
      width: 80%;
      background: #333;
      border-radius: 5px;
      margin: 1em 0;
      display: none;
    }
    #progressbar {
      height: 20px;
      width: 0%;
      background: #005599;
      border-radius: 5px;
      transition: width 0.2s;
    }
    #progressmessage {
      margin: 0.5em;
      font-size: 0.9em;
      text-align: center;
    }
    #note {
      margin-top: 1em;
      font-size: 0.8em;
      color: #aaaaaa;
      text-align: center;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
  <div class="container">
    <h3>custom ascii converter</h3>
    <label>
      select file
      <input type="file" id="mediainput" accept="image/*,video/*">
    </label>
    <label>
      detail size columns
      <input type="number" id="detailsize" value="200" min="50" step="50">
    </label>
     <label id="playbackfpslabel" style="display: none;">
      playback fps
      <input type="number" id="playbackfps" value="15" min="1">
    </label>
     <label id="renderfpslabel" style="display: none;">
      render fps
      <input type="number" id="renderfps" value="30" min="1">
    </label>
    <div>
      <button id="processbutton">process image</button>
      <button id="processandrenderbutton" style="display: none;">process and render video</button>
      <button id="savebutton">save ascii</button>
      <button id="togglecolour">colour mode off</button>
    </div>
    <div id="progresscontainer">
      <div id="progressbar"></div>
    </div>
    <div id="progressmessage"></div>
     <div id="note" style="display: none;"></div>
    <div id="display"></div>
  </div>
  <script>
    let custommedia = null;
    let customctx = null;
    let customcanvas = document.createElement("canvas");
    let custommediatype = null;
    let usecolour = false;
    let asciiData = [];
    const charset = ".,-~:;=!*#$@";
    const displayDiv = document.getElementById("display");
    const progresscontainer = document.getElementById("progresscontainer");
    const progressbar = document.getElementById("progressbar");
    const progressmessage = document.getElementById("progressmessage");
    const processbutton = document.getElementById("processbutton");
    const processandrenderbutton = document.getElementById("processandrenderbutton");
    const savebutton = document.getElementById("savebutton");
    const togglecolourbutton = document.getElementById("togglecolour");
    const detailsizeinput = document.getElementById("detailsize");
    const renderfpsinput = document.getElementById("renderfps");
    const renderfpslabel = document.getElementById("renderfpslabel");
    const playbackfpsinput = document.getElementById("playbackfps");
    const playbackfpslabel = document.getElementById("playbackfpslabel");
    const noteDiv = document.getElementById("note");

    let recordingCanvas = document.createElement("canvas");
    let recordingCtx = recordingCanvas.getContext("2d");

    let displayCanvas = document.createElement("canvas");
    let displayCtx = displayCanvas.getContext("2d");
    displayDiv.appendChild(displayCanvas);


    let mediaRecorder = null;
    let recordedChunks = [];
    let processingVideoForRender = false;
    let currentRenderFrame = 0;
    let totalRenderFrames = 0;
    let renderTargetFps = 30;

    let videoPlaybackLoopId = null;
    let videoPlaybackFps = 15;
    let lastPlaybackTime = 0;

    function drawMediaFrame() {
      let detail = parseInt(detailsizeinput.value) || 200;
      let aspect = 1;
      if (custommedia.videoWidth && custommedia.videoHeight) {
        aspect = custommedia.videoHeight / custommedia.videoWidth;
      } else if (custommedia.naturalWidth && custommedia.naturalHeight) {
        aspect = custommedia.naturalHeight / custommedia.naturalWidth;
      }
      customcanvas.width = detail;
      customcanvas.height = Math.floor(detail * aspect);
      customctx.drawImage(custommedia, 0, 0, customcanvas.width, customcanvas.height);
    }

    function convertFrameToAsciiAndDrawCanvases() {
      let imgdata = customctx.getImageData(0, 0, customcanvas.width, customcanvas.height).data;
      asciiData = [];
      const asciiWidth = customcanvas.width;
      const asciiHeight = customcanvas.height;

      const fontSize = 12;
      const charWidthRatio = 0.6;
      const lineHeightFactor = 1.2;

      recordingCanvas.width = asciiWidth * fontSize * charWidthRatio;
      recordingCanvas.height = asciiHeight * fontSize * lineHeightFactor;
      displayCanvas.width = asciiWidth * fontSize * charWidthRatio;
      displayCanvas.height = asciiHeight * fontSize * lineHeightFactor;


      recordingCtx.fillStyle = "#0a0a0a";
      recordingCtx.fillRect(0, 0, recordingCanvas.width, recordingCanvas.height);
      recordingCtx.font = `${fontSize}px monospace`;

      displayCtx.fillStyle = "#0a0a0a";
      displayCtx.fillRect(0, 0, displayCanvas.width, displayCanvas.height);
      displayCtx.font = `${fontSize}px monospace`;


      for (let y = 0; y < asciiHeight; y++) {
        let row = [];
        for (let x = 0; x < asciiWidth; x++) {
          let i = (y * asciiWidth + x) * 4;
          let r = imgdata[i];
          let g = imgdata[i + 1];
          let b = imgdata[i + 2];
          let brightness = 0.299 * r + 0.587 * g + 0.114 * b;
          let charindex = Math.floor((brightness / 255) * (charset.length - 1));
          let char = charset.charAt(charindex);
          let color = `rgb(${r},${g},${b})`;

          row.push({ char: char, color: color });

          const displayColor = usecolour ? color : "#e0e0e0";

          recordingCtx.fillStyle = displayColor;
          recordingCtx.fillText(char, x * fontSize * charWidthRatio, (y + 1) * fontSize * lineHeightFactor);

          displayCtx.fillStyle = displayColor;
          displayCtx.fillText(char, x * fontSize * charWidthRatio, (y + 1) * fontSize * lineHeightFactor);
        }
        asciiData.push(row);
      }
    }

    function processNextRenderFrame() {
         if (!processingVideoForRender || !custommedia) return;

         const targetTime = currentRenderFrame / renderTargetFps;

         if (targetTime >= custommedia.duration) {
             mediaRecorder.stop();
             custommedia.pause();
             custommedia.muted = true;
             return;
         }

         custommedia.currentTime = targetTime;
     }

     function videoPlaybackLoop(time) {
         if (!custommedia || custommediatype !== 'video' || processingVideoForRender) {
             videoPlaybackLoopId = null;
             return;
         }

         videoPlaybackLoopId = requestAnimationFrame(videoPlaybackLoop);

         const elapsedSinceLast = time - lastPlaybackTime;
         const frameInterval = 1000 / videoPlaybackFps;

         if (elapsedSinceLast < frameInterval) {
             return;
         }

         lastPlaybackTime = time - (elapsedSinceLast % frameInterval); // Adjust last time

         const targetTime = custommedia.currentTime + frameInterval / 1000;

         if (targetTime >= custommedia.duration) {
             custommedia.pause();
             custommedia.currentTime = 0; // Loop or stop as desired
             return;
         }

         custommedia.currentTime = targetTime;
         // The seeked event handler will draw the frame
     }


    async function startVideoRendering() {
        if (!custommedia || custommediatype !== 'video') return;

        // Stop playback loop if running
        if (videoPlaybackLoopId) {
            cancelAnimationFrame(videoPlaybackLoopId);
            videoPlaybackLoopId = null;
        }

        processingVideoForRender = true;
        disableButtons(true);
        progresscontainer.style.display = "block";
        progressmessage.textContent = "preparing for recording...";
        noteDiv.style.display = "block";
        noteDiv.textContent = "Note: Audio is played during recording but not saved in the final video file.";

        renderTargetFps = parseInt(renderfpsinput.value) || 30;
        const videoDuration = custommedia.duration;
        totalRenderFrames = Math.floor(videoDuration * renderTargetFps);
        currentRenderFrame = 0;

        let options = { mimeType: 'video/mp4;codecs=avc1.42E01E' };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
             options = { mimeType: 'video/webm;codecs=vp9' };
             if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                 options = { mimeType: 'video/webm' };
                 if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                     progressmessage.textContent = "Error: No supported video recording format found.";
                     disableButtons(false);
                     processingVideoForRender = false;
                     noteDiv.style.display = "none";
                     noteDiv.textContent = "";
                     return;
                 }
             }
             noteDiv.textContent += "\n(Using WebM format)";
        }

        recordedChunks = [];
        const stream = recordingCanvas.captureStream(renderTargetFps);
        mediaRecorder = new MediaRecorder(stream, options);

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: options.mimeType });
            saveAs(blob, "ascii_video.mp4");
            progressmessage.textContent = "encoding complete";
            disableButtons(false);
            processingVideoForRender = false;
            noteDiv.style.display = "none";
            noteDiv.textContent = "";

            // Restart playback loop if needed
            if (custommediatype === 'video') {
                 custommedia.currentTime = 0;
                 custommedia.muted = true; // Keep muted after render
                 startVideoPlaybackLoop();
            }


            setTimeout(() => {
                progresscontainer.style.display = "none";
                progressmessage.textContent = "";
            }, 2000);
        };

        mediaRecorder.onerror = (event) => {
             progressmessage.textContent = "Error during recording: " + event.error.name;
             disableButtons(false);
             processingVideoForRender = false;
             noteDiv.style.display = "none";
             noteDiv.textContent = "";
             console.error("MediaRecorder error:", event.error);
             // Restart playback loop if needed
            if (custommediatype === 'video') {
                 custommedia.currentTime = 0;
                 custommedia.muted = true;
                 startVideoPlaybackLoop();
            }
        }

        custommedia.currentTime = 0;
        custommedia.muted = false;
        custommedia.volume = 1;
        await custommedia.play();

        mediaRecorder.start();

        processNextRenderFrame();
    }

    function startVideoPlaybackLoop() {
        if (custommediatype === 'video' && !processingVideoForRender && !videoPlaybackLoopId) {
            videoPlaybackFps = parseInt(playbackfpsinput.value) || 15;
            lastPlaybackTime = performance.now();
            custommedia.muted = true; // Play silently for display
             custommedia.pause(); // Ensure it's not playing independently
            videoPlaybackLoop(performance.now()); // Start the loop
        }
    }


    document.getElementById("mediainput").addEventListener("change", (event) => {
      const fileinput = event.target;
      if (fileinput.files.length === 0) return;
      let file = fileinput.files[0];
      let url = URL.createObjectURL(file);

      if (custommedia) {
          if (custommedia.tagName === 'VIDEO') {
              custommedia.pause();
              custommedia.removeAttribute('src');
              custommedia.load();
          }
           if (videoPlaybackLoopId) {
                cancelAnimationFrame(videoPlaybackLoopId);
                videoPlaybackLoopId = null;
           }
      }

      if (file.type.startsWith("image")) {
        custommediatype = "image";
        processbutton.textContent = "process image";
        savebutton.textContent = "save ascii image";
        processbutton.style.display = "inline-block";
        processandrenderbutton.style.display = "none";
        renderfpslabel.style.display = "none";
        playbackfpslabel.style.display = "none";
        noteDiv.style.display = "none";
        noteDiv.textContent = "";


        custommedia = new Image();
        custommedia.onload = () => {
          customcanvas = document.createElement("canvas");
          customctx = customcanvas.getContext("2d");
        }
        custommedia.onerror = () => {
            progressmessage.textContent = "Error loading image.";
            setTimeout(() => { progressmessage.textContent = ""; }, 2000);
        }
        custommedia.src = url;

      } else if (file.type.startsWith("video")) {
        custommediatype = "video";
        processbutton.textContent = "process video (first frame)";
        savebutton.textContent = "render video";
        processbutton.style.display = "inline-block";
        processandrenderbutton.style.display = "inline-block";
        renderfpslabel.style.display = "inline-block";
        playbackfpslabel.style.display = "inline-block";
        noteDiv.style.display = "block";
        noteDiv.textContent = "Click 'process video' to see the first frame or 'process and render video' to generate the full video.";


        custommedia = document.createElement("video");
        custommedia.autoplay = false;
        custommedia.loop = false;
        custommedia.muted = true;
        custommedia.volume = 0; // Ensure it's silent

        custommedia.onloadedmetadata = () => {
             customcanvas = document.createElement("canvas");
             customctx = customcanvas.getContext("2d");
             custommedia.currentTime = 0;
        }

        custommedia.onseeked = () => {
             drawMediaFrame();
             convertFrameToAsciiAndDrawCanvases();

             if (processingVideoForRender) {
                 currentRenderFrame++;
                 const percent = Math.min(Math.floor((currentRenderFrame / totalRenderFrames) * 100), 100);
                 const elapsedSeconds = Math.floor(custommedia.currentTime);
                 const remainingSeconds = Math.max(0, Math.floor(custommedia.duration - custommedia.currentTime));

                 progressbar.style.width = percent + "%";
                 progressmessage.textContent = `progress: ${percent}% (${elapsedSeconds}s done, ${remainingSeconds}s left)`;

                 processNextRenderFrame();
             }
             // The display canvas is already updated in convertFrameToAsciiAndDrawCanvases for both cases
        }

         custommedia.onerror = () => {
            progressmessage.textContent = "Error loading video.";
            setTimeout(() => { progressmessage.textContent = ""; }, 2000);
        }

        custommedia.onplay = () => {
             // Start the playback loop when the video is programmatically played (for audio sync during render)
             if (processingVideoForRender) {
                  // This happens during rendering - loop is controlled by seeked handler
             } else {
                 // If video was somehow played outside render (shouldn't happen with muted=true and no controls)
             }
        }
         custommedia.onpause = () => {
             // Pause playback loop if paused manually
              if (!processingVideoForRender && videoPlaybackLoopId) {
                  cancelAnimationFrame(videoPlaybackLoopId);
                  videoPlaybackLoopId = null;
              }
         }
        custommedia.onended = () => {
             // Stop playback loop if video ends
             if (!processingVideoForRender && videoPlaybackLoopId) {
                  cancelAnimationFrame(videoPlaybackLoopId);
                  videoPlaybackLoopId = null;
                  custommedia.currentTime = 0; // Reset to start
                  // Optionally re-start loop here for continuous playback
                  // startVideoPlaybackLoop();
             }
        }


        custommedia.src = url;

      } else {
           progressmessage.textContent = "Unsupported file type selected.";
           custommediatype = null;
           custommedia = null;
           displayDiv.innerHTML = ''; // Clear canvas from display div
           displayDiv.appendChild(displayCanvas); // Re-append the canvas
           processbutton.style.display = "inline-block";
           processandrenderbutton.style.display = "none";
           savebutton.textContent = "save ascii";
           renderfpslabel.style.display = "none";
           playbackfpslabel.style.display = "none";
           noteDiv.style.display = "none";
           noteDiv.textContent = "";
           setTimeout(() => { progressmessage.textContent = ""; }, 2000);
      }
    });

    processbutton.addEventListener("click", () => {
      if (!custommedia) {
           progressmessage.textContent = "Please select a file first.";
           setTimeout(() => { progressmessage.textContent = ""; }, 2000);
           return;
      }
      if (custommediatype === 'image') {
         drawMediaFrame();
         convertFrameToAsciiAndDrawCanvases(); // Process and draw for image
      } else if (custommediatype === 'video') {
         // For video, seek to the current time (or 0) to trigger a seeked event
         // The seeked handler will draw and convert for display
          custommedia.currentTime = custommedia.currentTime || 0;
          // Start playback loop if not already running
          startVideoPlaybackLoop();
      }
    });

     processandrenderbutton.addEventListener("click", () => {
         if (!custommedia || custommediatype !== 'video') {
              progressmessage.textContent = "Please select a video file first.";
              setTimeout(() => { progressmessage.textContent = ""; }, 2000);
              return;
         }
         startVideoRendering();
     });

    savebutton.addEventListener("click", () => {
      if (!custommedia) {
           progressmessage.textContent = "Nothing to save.";
           setTimeout(() => { progressmessage.textContent = ""; }, 2000);
           return;
      }

      if (custommediatype === "video") {
         startVideoRendering();
      } else {
        // For images, save based on the asciiData array like the original code
        if (asciiData.length === 0) {
             progressmessage.textContent = "Please click 'process image' first.";
             setTimeout(() => { progressmessage.textContent = ""; }, 2000);
             return;
        }

        const rows = asciiData.length;
        const cols = asciiData[0].length;
        const fontsize = 10;
        const lineheight = fontsize * 1.2;
        const canvasw = cols * fontsize * 0.6;
        const canvash = rows * lineheight;
        const offcanvas = document.createElement("canvas");
        offcanvas.width = canvasw;
        offcanvas.height = canvash;
        const offctx = offcanvas.getContext("2d");
        offctx.fillStyle = "#0a0a0a";
        offctx.fillRect(0, 0, canvasw, canvash);
        offctx.font = fontsize + "px monospace";
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            let obj = asciiData[y][x];
            offctx.fillStyle = usecolour ? obj.color : "#e0e0e0"; // Use colour setting here
            offctx.fillText(obj.char, x * fontsize * 0.6, (y + 1) * lineheight);
          }
        }

        offcanvas.toBlob(blob => {
          saveAs(blob, "ascii_art.png");
          progressmessage.textContent = "Image saved!";
          setTimeout(() => { progressmessage.textContent = ""; }, 2000);
        });
      }
    });

    togglecolourbutton.addEventListener("click", function () {
      usecolour = !usecolour;
      this.textContent = usecolour ? "colour mode on" : "colour mode off";
      if (custommedia) {
          if (custommediatype === 'image' && asciiData.length > 0) {
               drawMediaFrame();
               convertFrameToAsciiAndDrawCanvases();
          } else if (custommediatype === 'video' && custommedia.readyState >= 2) {
              custommedia.currentTime = custommedia.currentTime;
          }
      }
    });

     detailsizeinput.addEventListener("change", () => {
         if (custommedia) {
             if (custommediatype === 'image' && asciiData.length > 0) {
                drawMediaFrame();
                convertFrameToAsciiAndDrawCanvases();
             } else if (custommediatype === 'video' && custommedia.readyState >= 2) {
                custommedia.currentTime = custommedia.currentTime;
             }
         }
     });

     playbackfpsinput.addEventListener("change", () => {
        if (custommediatype === 'video' && !processingVideoForRender) {
             videoPlaybackFps = parseInt(playbackfpsinput.value) || 15;
             // Restart playback loop to apply new FPS
             if (videoPlaybackLoopId) {
                  cancelAnimationFrame(videoPlaybackLoopId);
                  videoPlaybackLoopId = null;
             }
             startVideoPlaybackLoop();
        }
     });

    function disableButtons(disabled) {
        processbutton.disabled = disabled;
        processandrenderbutton.disabled = disabled;
        savebutton.disabled = disabled;
        togglecolourbutton.disabled = disabled;
        detailsizeinput.disabled = disabled;
        renderfpsinput.disabled = disabled;
        playbackfpsinput.disabled = disabled;
        document.getElementById("mediainput").disabled = disabled;
        document.querySelector('label[for="mediainput"]').style.pointerEvents = disabled ? 'none' : 'auto';
    }

  </script>
</body>
  </html>
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>custom ascii converter</title>
  <script>
    if (/mobi|android/i.test(navigator.userAgent)) {
      let meta = document.createElement("meta");
      meta.name = "viewport";
      meta.content = "width=device-width,initial-scale=1,minimum-scale=0.1,maximum-scale=5,user-scalable=yes";
      document.getElementsByTagName("head")[0].appendChild(meta);
    }
  </script>
  <style>
    body {
      margin: 0;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: monospace;
    }
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1em;
    }
    button,
    input[type="button"],
    input[type="submit"],
    input[type="reset"] {
      background: #003366;
      border: none;
      color: #e0e0e0;
      padding: 0.5em 1em;
      margin: 0.5em;
      font-size: 1em;
      border-radius: 4px;
      transition: background 0.3s;
      cursor: pointer;
    }
    button:hover,
    input[type="button"]:hover,
    input[type="submit"]:hover,
    input[type="reset"]:hover {
      background: #005599;
    }

    input[type="file"] {
      display: none;
    }
    label {
       background: #003366;
      border: none;
      color: #e0e0e0;
      padding: 0.5em 1em;
      margin: 0.5em;
      font-size: 1em;
      border-radius: 4px;
      transition: background 0.3s;
      cursor: pointer;
      display: inline-block;
    }
     label:hover {
      background: #005599;
    }

    input[type="number"] {
       background: #003366;
       border: none;
       color: #e0e0e0;
       padding: 0.5em 1em;
       margin: 0.5em;
       font-size: 1em;
       border-radius: 4px;
       transition: background 0.3s;
    }


    pre {
      white-space: pre;
      font-size: 1em;
      line-height: 1em;
      margin: 0;
      padding: 1em;
      width: 90%;
      overflow-x: auto;
      word-wrap: normal;
    }
    #progresscontainer {
      width: 80%;
      background: #333;
      border-radius: 5px;
      margin: 1em 0;
      display: none;
    }
    #progressbar {
      height: 20px;
      width: 0%;
      background: #005599;
      border-radius: 5px;
      transition: width 0.2s;
    }
    #progressmessage {
      margin: 0.5em;
      font-size: 0.9em;
      text-align: center;
    }
    #note {
      margin-top: 1em;
      font-size: 0.8em;
      color: #aaaaaa;
      text-align: center;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
  <div class="container">
    <h3>custom ascii converter</h3>
    <label>
      select file
      <input type="file" id="mediainput" accept="image/*,video/*">
    </label>
    <label>
      detail size columns
      <input type="number" id="detailsize" value="200" min="50" step="50">
    </label>
     <label id="fpslabel" style="display: none;">
      render fps
      <input type="number" id="renderfps" value="30" min="1">
    </label>
    <div>
      <button id="processbutton">process image</button>
      <button id="processandrenderbutton" style="display: none;">process and render video</button>
      <button id="savebutton">save ascii</button>
      <button id="togglecolour">colour mode off</button>
    </div>
    <div id="progresscontainer">
      <div id="progressbar"></div>
    </div>
    <div id="progressmessage"></div>
     <div id="note" style="display: none;"></div>
    <pre id="display"></pre>
  </div>
  <script>
    let custommedia = null;
    let customctx = null;
    let customcanvas = document.createElement("canvas");
    let custommediatype = null;
    let usecolour = false;
    let asciiData = [];
    const charset = ".,-~:;=!*#$@";
    const display = document.getElementById("display");
    const progresscontainer = document.getElementById("progresscontainer");
    const progressbar = document.getElementById("progressbar");
    const progressmessage = document.getElementById("progressmessage");
    const processbutton = document.getElementById("processbutton");
    const processandrenderbutton = document.getElementById("processandrenderbutton");
    const savebutton = document.getElementById("savebutton");
    const togglecolourbutton = document.getElementById("togglecolour");
    const detailsizeinput = document.getElementById("detailsize");
    const fpsinput = document.getElementById("renderfps");
    const fpslabel = document.getElementById("fpslabel");
    const noteDiv = document.getElementById("note");

    let recordingCanvas = document.createElement("canvas");
    let recordingCtx = recordingCanvas.getContext("2d");

    let mediaRecorder = null;
    let recordedChunks = [];
    let processingVideo = false;
    let currentRenderFrame = 0;
    let totalRenderFrames = 0;
    let renderTargetFps = 30;

    function drawMediaFrame() {
      let detail = parseInt(detailsizeinput.value) || 200;
      let aspect = 1;
      if (custommedia.videoWidth && custommedia.videoHeight) {
        aspect = custommedia.videoHeight / custommedia.videoWidth;
      } else if (custommedia.naturalWidth && custommedia.naturalHeight) {
        aspect = custommedia.naturalHeight / custommedia.naturalHeight; // Should be naturalHeight / naturalWidth
        aspect = custommedia.naturalHeight / custommedia.naturalWidth;
      }
      customcanvas.width = detail;
      customcanvas.height = Math.floor(detail * aspect);
      customctx.drawImage(custommedia, 0, 0, customcanvas.width, customcanvas.height);
    }

    function convertFrameToAscii() {
      let imgdata = customctx.getImageData(0, 0, customcanvas.width, customcanvas.height).data;
      asciiData = [];
      let htmlout = "";
      const asciiWidth = customcanvas.width;
      const asciiHeight = customcanvas.height;

      const fontSize = 12;
      const charWidthRatio = 0.6;
      const lineHeightFactor = 1.2;

      recordingCanvas.width = asciiWidth * fontSize * charWidthRatio;
      recordingCanvas.height = asciiHeight * fontSize * lineHeightFactor;

      recordingCtx.fillStyle = "#0a0a0a";
      recordingCtx.fillRect(0, 0, recordingCanvas.width, recordingCanvas.height);
      recordingCtx.font = `${fontSize}px monospace`;

      for (let y = 0; y < asciiHeight; y++) {
        let row = [];
        for (let x = 0; x < asciiWidth; x++) {
          let i = (y * asciiWidth + x) * 4;
          let r = imgdata[i];
          let g = imgdata[i + 1];
          let b = imgdata[i + 2];
          let brightness = 0.299 * r + 0.587 * g + 0.114 * b;
          let charindex = Math.floor((brightness / 255) * (charset.length - 1));
          let char = charset.charAt(charindex);
          let color = `rgb(${r},${g},${b})`;

          row.push({ char: char, color: color });
          if (!processingVideo) {
             if (usecolour) {
                htmlout += `<span style="color: ${color}">${char}</span>`;
             } else {
                htmlout += char;
             }
          }


          recordingCtx.fillStyle = usecolour ? color : "#e0e0e0";
          recordingCtx.fillText(char, x * fontSize * charWidthRatio, (y + 1) * fontSize * lineHeightFactor);
        }
        if (!processingVideo) {
             htmlout += "<br>";
        }
      }

      if (!processingVideo) {
         display.innerHTML = htmlout;
      }
    }

    function processNextRenderFrame() {
         if (!processingVideo) return;

         const targetTime = currentRenderFrame / renderTargetFps;

         if (targetTime >= custommedia.duration) {
             mediaRecorder.stop();
             custommedia.pause();
             custommedia.muted = true;
             return;
         }

         custommedia.currentTime = targetTime;
         // The actual frame processing (drawMediaFrame, convertFrameToAscii)
         // happens in the custommedia.onseeked handler
     }

    async function startVideoRendering() {
        if (!custommedia || custommediatype !== 'video') return;

        processingVideo = true;
        disableButtons(true);
        progresscontainer.style.display = "block";
        progressmessage.textContent = "preparing for recording...";
        noteDiv.style.display = "block";
        noteDiv.textContent = "Note: Audio is played during recording but not saved in the final video file.";

        renderTargetFps = parseInt(fpsinput.value) || 30;
        const videoDuration = custommedia.duration;
        totalRenderFrames = Math.floor(videoDuration * renderTargetFps);
        currentRenderFrame = 0;

        let options = { mimeType: 'video/mp4;codecs=avc1.42E01E' };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
             options = { mimeType: 'video/webm;codecs=vp9' };
             if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                 options = { mimeType: 'video/webm' };
                 if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                     progressmessage.textContent = "Error: No supported video recording format found.";
                     disableButtons(false);
                     processingVideo = false;
                     noteDiv.style.display = "none";
                     noteDiv.textContent = "";
                     return;
                 }
             }
             noteDiv.textContent += "\n(Using WebM format)";
        }

        recordedChunks = [];
        const stream = recordingCanvas.captureStream(renderTargetFps);
        mediaRecorder = new MediaRecorder(stream, options);

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: options.mimeType });
            saveAs(blob, "ascii_video.mp4");
            progressmessage.textContent = "encoding complete";
            disableButtons(false);
            processingVideo = false;
            noteDiv.style.display = "none";
            noteDiv.textContent = "";

            setTimeout(() => {
                progresscontainer.style.display = "none";
                progressmessage.textContent = "";
            }, 2000);
        };

        mediaRecorder.onerror = (event) => {
             progressmessage.textContent = "Error during recording: " + event.error.name;
             disableButtons(false);
             processingVideo = false;
             noteDiv.style.display = "none";
             noteDiv.textContent = "";
             console.error("MediaRecorder error:", event.error);
        }

        custommedia.currentTime = 0;
        custommedia.muted = false;
        custommedia.volume = 1;
        await custommedia.play();

        mediaRecorder.start();

        processNextRenderFrame(); // Start the frame processing loop
    }


    document.getElementById("mediainput").addEventListener("change", (event) => {
      const fileinput = event.target;
      if (fileinput.files.length === 0) return;
      let file = fileinput.files[0];
      let url = URL.createObjectURL(file);

      if (custommedia) {
          if (custommedia.tagName === 'VIDEO') {
              custommedia.pause();
              custommedia.removeAttribute('src');
              custommedia.load();
          }
      }

      if (file.type.startsWith("image")) {
        custommediatype = "image";
        processbutton.textContent = "process image";
        savebutton.textContent = "save ascii image";
        processbutton.style.display = "inline-block";
        processandrenderbutton.style.display = "none";
        fpslabel.style.display = "none";
        noteDiv.style.display = "none";
        noteDiv.textContent = "";
        display.style.whiteSpace = 'pre';

        custommedia = new Image();
        custommedia.onload = () => {
          customcanvas = document.createElement("canvas");
          customctx = customcanvas.getContext("2d");
          // Optional: Auto-process image on load
          // drawMediaFrame();
          // convertFrameToAscii();
        }
        custommedia.onerror = () => {
            progressmessage.textContent = "Error loading image.";
            setTimeout(() => { progressmessage.textContent = ""; }, 2000);
        }
        custommedia.src = url;

      } else if (file.type.startsWith("video")) {
        custommediatype = "video";
        processbutton.textContent = "process video (first frame)";
        savebutton.textContent = "render video";
        processbutton.style.display = "inline-block";
        processandrenderbutton.style.display = "inline-block";
        fpslabel.style.display = "inline-block";
        noteDiv.style.display = "block";
        noteDiv.textContent = "Click 'process video' to see the first frame or 'process and render video' to generate the full video.";
        display.style.whiteSpace = 'pre-wrap';

        custommedia = document.createElement("video");
        custommedia.autoplay = false;
        custommedia.loop = false;
        custommedia.muted = true;

        custommedia.onloadedmetadata = () => {
             customcanvas = document.createElement("canvas");
             customctx = customcanvas.getContext("2d");
             custommedia.currentTime = 0; // Seek to beginning to load first frame metadata
        }

        custommedia.onseeked = () => {
             // This handler is called after any seek operation (user click, programatic seek)
             drawMediaFrame();
             convertFrameToAscii(); // Convert and draw on recording canvas

             if (processingVideo) {
                  // If we are in the middle of a video render process, continue to the next frame
                 currentRenderFrame++;
                 const percent = Math.min(Math.floor((currentRenderFrame / totalRenderFrames) * 100), 100);
                 const elapsedSeconds = Math.floor(custommedia.currentTime);
                 const remainingSeconds = Math.max(0, Math.floor(custommedia.duration - custommedia.currentTime));

                 progressbar.style.width = percent + "%";
                 progressmessage.textContent = `progress: ${percent}% (${elapsedSeconds}s done, ${remainingSeconds}s left)`;

                 // Process the next frame
                 processNextRenderFrame();
             } else {
                  // If not processing video, this seek was likely from user interaction
                  // Update the display with the current frame's ASCII
                  let imgdata = customctx.getImageData(0, 0, customcanvas.width, customcanvas.height).data;
                  let htmlout = "";
                  const asciiWidth = customcanvas.width;
                  for (let y = 0; y < customcanvas.height; y++) {
                     for (let x = 0; x < asciiWidth; x++) {
                        let i = (y * asciiWidth + x) * 4;
                        let r = imgdata[i];
                        let g = imgdata[i + 1];
                        let b = imgdata[i + 2];
                        let color = `rgb(${r},${g},${b})`;
                         let brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                         let charindex = Math.floor((brightness / 255) * (charset.length - 1));
                         let char = charset.charAt(charindex);

                        if (usecolour) {
                            htmlout += `<span style="color: ${color}">${char}</span>`;
                        } else {
                            htmlout += char;
                        }
                     }
                     htmlout += "<br>";
                  }
                  display.innerHTML = htmlout;
             }
        }
         custommedia.onerror = () => {
            progressmessage.textContent = "Error loading video.";
            setTimeout(() => { progressmessage.textContent = ""; }, 2000);
        }
        custommedia.src = url;

      } else {
           progressmessage.textContent = "Unsupported file type selected.";
           custommediatype = null;
           custommedia = null;
           display.innerHTML = "";
           processbutton.style.display = "inline-block";
           processandrenderbutton.style.display = "none";
           savebutton.textContent = "save ascii";
           fpslabel.style.display = "none";
           noteDiv.style.display = "none";
           noteDiv.textContent = "";
           setTimeout(() => { progressmessage.textContent = ""; }, 2000);
      }
    });

    processbutton.addEventListener("click", () => {
      if (!custommedia) {
           progressmessage.textContent = "Please select a file first.";
           setTimeout(() => { progressmessage.textContent = ""; }, 2000);
           return;
      }
      if (custommediatype === 'image') {
         drawMediaFrame();
         convertFrameToAscii(); // This populates asciiData and updates display/recordingCanvas
      } else if (custommediatype === 'video') {
         // For video, just seek to the current time (or 0) to trigger a seeked event
         // The seeked handler will draw and convert for display
          custommedia.currentTime = custommedia.currentTime || 0; // Seek to current or start
      }
    });

     processandrenderbutton.addEventListener("click", () => {
         if (!custommedia || custommediatype !== 'video') {
              progressmessage.textContent = "Please select a video file first.";
              setTimeout(() => { progressmessage.textContent = ""; }, 2000);
              return;
         }
         startVideoRendering();
     });

    savebutton.addEventListener("click", () => {
      if (!custommedia) {
           progressmessage.textContent = "Nothing to save.";
           setTimeout(() => { progressmessage.textContent = ""; }, 2000);
           return;
      }

      if (custommediatype === "video") {
         // If save is clicked for video, trigger render
         startVideoRendering();
      } else {
        // For images, save the recorded canvas content
        if (asciiData.length === 0) { // Check if asciiData is populated (process clicked)
             progressmessage.textContent = "Please click 'process image' first.";
             setTimeout(() => { progressmessage.textContent = ""; }, 2000);
             return;
        }
        recordingCanvas.toBlob(blob => {
          saveAs(blob, "ascii_art.png");
          progressmessage.textContent = "Image saved!";
          setTimeout(() => { progressmessage.textContent = ""; }, 2000);
        });
      }
    });

    togglecolourbutton.addEventListener("click", function () {
      usecolour = !usecolour;
      this.textContent = usecolour ? "colour mode on" : "colour mode off";
      // Re-render the current view with the new colour setting
      if (custommedia && custommediatype === 'image') {
           if (asciiData.length > 0) { // Only re-render if image was processed
               drawMediaFrame();
               convertFrameToAscii();
           }
      } else if (custommedia && custommediatype === 'video' && custommedia.readyState >= 2) {
            // Trigger a seek to the current time to re-render the display with new colour
            custommedia.currentTime = custommedia.currentTime;
      }
    });

     detailsizeinput.addEventListener("change", () => {
         // Re-render the current view with the new detail size
         if (custommedia && custommediatype === 'image') {
             if (asciiData.length > 0) { // Only re-render if image was processed
                drawMediaFrame();
                convertFrameToAscii();
             }
         } else if (custommedia && custommediatype === 'video' && custommedia.readyState >= 2) {
             custommedia.currentTime = custommedia.currentTime; // Trigger seeked
         }
     });

    function disableButtons(disabled) {
        processbutton.disabled = disabled;
        processandrenderbutton.disabled = disabled;
        savebutton.disabled = disabled;
        togglecolourbutton.disabled = disabled;
        detailsizeinput.disabled = disabled;
        fpsinput.disabled = disabled;
        document.getElementById("mediainput").disabled = disabled;
        document.querySelector('label[for="mediainput"]').style.pointerEvents = disabled ? 'none' : 'auto';
    }

  </script>
</body>
  </html>